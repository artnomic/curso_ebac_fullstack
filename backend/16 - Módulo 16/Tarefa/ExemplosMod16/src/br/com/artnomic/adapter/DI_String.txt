"Injeção de Dependências com String", não é bem um padrão de projeto formal em Java. Na verdade, a maioria das pessoas que estudam isso a considera um anti-padrão. Basicamente, a ideia é que, em vez de um objeto receber suas dependências já prontas, ele vai lá e "pede" por elas usando uma string, tipo um nome, para que algum tipo de "localizador" entregue o que ele precisa.

No meu estudo, percebi que essa abordagem de usar strings pode ter aparecido em situações mais antigas ou em frameworks que buscavam muita flexibilidade, talvez sem se preocupar tanto com a segurança de que o tipo do objeto estaria correto. Por exemplo, dava para ter uma configuração bem dinâmica, sabe? Era só mudar uma string em um arquivo e a implementação do serviço mudava, sem precisar recompilar tudo. Para quem estava começando ou em projetos muito pequenos, usar um nome para pedir algo podia parecer bem simples, ainda mais se a gente já estivesse acostumado com mapas de chave-valor. E sim, alguns Service Locators mais antigos funcionavam registrando e recuperando serviços por esses nomes de string.

Mas para a maioria dos cenários de desenvolvimento Java moderno, eu já entendi que não devo usar a "Injeção de Dependências com String" para gerenciar minhas dependências. O "quando usar" é quase um "nunca usar", porque as desvantagens são muito maiores que qualquer benefício que ela pudesse oferecer. A primeira e mais grave é a falta de segurança de tipo. O compilador Java simplesmente não consegue verificar se a string que estou usando realmente corresponde a uma dependência válida. Se eu errar uma letrinha no nome, o problema só vai aparecer na hora que o programa estiver rodando? Aí dá erro tipo ClassCastException ou NullPointerException, e isso é bem chato de depurar, muito pior do que um erro que o compilador me mostra na hora.

Outro ponto que me chamou atenção é a dificuldade de refatoração. As ferramentas automáticas das IDEs, que são super úteis, não conseguem entender que uma string está ligada a uma classe. Se eu renomeio uma classe que está sendo "injetada" por uma string, tenho que sair caçando todas as ocorrências daquela string no código para atualizar manualmente, e isso é um prato cheio para cometer erros. E por mais que pareça que o código está desacoplado, ele na verdade tem um acoplamento oculto bem forte àquela "string mágica". Isso significa que o código que usa a dependência fica preso àquela convenção de nome que eu inventei ou ao sistema que resolve a string. Ah, e a legibilidade e manutenção também pioram bastante, porque sem um nome de tipo claro, eu preciso saber de cabeça o que cada string representa. E o pior: sem a verificação do compilador, a chance de ter bugs em produção aumenta muito. Tornando impossível em um "código profissional".

Por tudo isso, eu aprendi que o padrão Injeção de Dependências (DI) de verdade, aquele implementado por frameworks de DI modernos, é muito melhor e é o que a galera em Java usa de verdade. Ele me ajuda a escrever um código mais limpo, fácil de testar e de manter. Em vez de strings, frameworks como Spring, Guice ou CDI (Jakarta EE) usam abordagens muito mais seguras.

A mais recomendada é a Injeção por Construtor, onde as dependências são passadas como argumentos para o construtor da classe, garantindo que o objeto sempre comece válido. Tem também a Injeção por Setter, que usa métodos públicos para injetar as dependências, e a Injeção por Campo (Field Injection), que injeta direto nos campos da classe com a ajuda de anotações. Esses frameworks usam os próprios tipos Java (interfaces e classes) e anotações para gerenciar e injetar as dependências de um jeito seguro e eficiente, fazendo as verificações necessárias já na hora da compilação.

Então, resumindo, a "Injeção de Dependências com String" é uma prática que eu devo evitar a todo custo. O ideal é focar em usar a Injeção de Dependências "verdadeira", com a ajuda de um framework robusto, para construir aplicações Java que sejam modernas e de alta qualidade.